import math
'''def d(p,q):
 R=range;D=len(p);F=len(q)-1;d=q[0];q=[q[i]/-d for i in R(1,F+1)];r=[0 for i in R(D)];a=[[0 for i in R(F)] for i in R(D)]
 for i in R(D):
  p[i]/=d;r[i]=sum(a[i])+p[i]
  for j in R(F):
   if i<D-F:a[i+j+1][F-j-1]=r[i]*q[j]
 return r[:D-F],[d*i for i in r[D-F:]]
p=[1., 0, 1., 1.]
q=[1.,1.,1.]
print(d(p,q)[0])
print(d(p,q)[1])
'''
# ax= (x^2 x+ 1) G(x)= (x^3 + x + 1) Eculid mở rộng [GF(2^3)]
# By: Nam AT160632

# săp xếp lũy thừa của đa thức từ thấp tới cao
# Eg.: x^4 + x + 1 => 1.x^0 + 1.x^1 + 0.x^2 + 0.x^3 + 1.x^4
r1 = [1,1,0,1]
# Eg.: x^2 + 1 => 1.x^0 + 0.x^1 + 1.x^2
r2 = [1,1,1]

# Creating a copy of r1 and r2 in a and b respectively
a = list(r1)
b = list(r2)
itr = 1

# Function to find degree of the polynimial: tìm bậc của đa thức
def getDegree(a):
    global deg
    for i in range(len(a)):
        if a[i] != 0:
            deg = i
    return deg

# Hàm chia a1: số bị chia. b1: số chia
def doDivision(a1,b1):
    
    # Initialize quotient list with 0s of size as r1
    # Khởi tạo mảng số thương độ dài r1
    qq = [0]*len(r1)
    
    ai = getDegree(a1)
    bj = getDegree(b1)    
    
    while ai >= bj and 1 in a1:
        t_pow = ai-bj
        t_coeff = a1[ai]/b1[bj]
        
        qq[t_pow] = t_coeff
        
        # Initializing temporary list for intermediate products
        t_mul = [0]*len(r1)
        
        # Multipliying divisor with quotient
        for i in range(bj+1):
            t_mul[i+t_pow] = b1[i]*t_coeff
            
        # New intermediate dividend
        for i in range(len(a1)):
            a1[i] = math.fmod(a1[i] - t_mul[i],2)
                 
        ai = getDegree(a1)
    
    return qq, a1

# Initialize t1 list as 0
t1 = [0]*len(r1)

# Initialize t2 list as 1
t2 = [0]*len(r1)
t2[0] = 1

# Initialize t list as 0
t = [0]*len(r1)

# Extended Euclidean Algorithm
while 1 in b:
    """print('\n'+str(itr))
    print('Dividend: '+str(a))
    print('Divisor: '+str(b))"""
    quot, rem = doDivision(a,b)
    """print('\nQuotient: '+str(quot))
    print('Remainder: '+str(rem))"""
    
    #Initializing intermediate list for quotient * t2
    t_qt2 = [0]*len(r1)
    d_quot = getDegree(quot)
    d_t2 = getDegree(t2)
    
    # Multipliying quotient and t2
    for i in range(d_quot+1):
        for j in range(d_t2+1):
            t_qt2[i+j] = t_qt2[i+j] + (quot[i] * t2[j])
        

    # Calculating t = t1 - quotient * t2
    for i in range(len(r1)):
        t[i] = math.fmod(t1[i] - t_qt2[i],2)
    
    # Checking the degree of t: if deg(t) == deg(r1), then perform t = t math.fmodulo r1
    if getDegree(r1) == getDegree(t):

       # print('\nt needs to perform math.fmodulo n')
      #  print('t_value before math.fmodulo: '+str(t))
        t_quo, t_rem = doDivision(t,r1)
        t = list(t_rem)
        
    
    '''print('\nt1: '+str(t1))
    print('t2: '+str(t2))
    print('t: '+str(t))'''
    a = list(b)
    b = list(rem)
    t1 = list(t2)
    t2 = list(t)

    itr = itr+1
    
# The result can be generated by rearranging the cofficients in the list from lower power to higher power   
print( " ax= (x^2 x+ 1) G(x)= (x^3 + x + 1) Eculid mở rộng [GF(2^3)]")
print("săp xep tu duoi len tren ta duoc")
print('g(x)='+str(r1))
print('a(x)='+str(r2))
print('\nNghich dao cua da thuc la: '+str(t1))
print("săp xep tu duoi len tren ta duoc x^2")

    